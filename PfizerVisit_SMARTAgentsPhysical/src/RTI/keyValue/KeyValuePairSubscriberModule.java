package RTI.keyValue;


/* keyValuePairSubscriber.java

   A publication of data of type keyValuePair

   This file is derived from code automatically generated by the rtiddsgen 
   command:

   rtiddsgen -language java -example <arch> .idl

   Example publication of type keyValuePair automatically generated by 
   'rtiddsgen' To test them follow these steps:

   (1) Compile this file and the example subscription.

   (2) Start the subscription on the same domain used for with the command
       java keyValuePairSubscriber <domain_id> <sample_count>

   (3) Start the publication with the command
       java keyValuePairPublisher <domain_id> <sample_count>

   (4) [Optional] Specify the list of discovery initial peers and 
       multicast receive addresses via an environment variable or a file 
       (in the current working directory) called NDDS_DISCOVERY_PEERS. 
       
   You can run any number of publishers and subscribers programs, and can 
   add and remove them dynamically from the domain.
              
                                   
   Example:
        
       To run the example application on domain <domain_id>:
            
       Ensure that $(NDDSHOME)/lib/<arch> is on the dynamic library path for
       Java.                       
       
        On UNIX systems: 
             add $(NDDSHOME)/lib/<arch> to the 'LD_LIBRARY_PATH' environment
             variable
                                         
        On Windows systems:
             add %NDDSHOME%\lib\<arch> to the 'Path' environment variable
                        

       Run the Java applications:
       
        java -Djava.ext.dirs=$NDDSHOME/class keyValuePairPublisher <domain_id>

        java -Djava.ext.dirs=$NDDSHOME/class keyValuePairSubscriber <domain_id>  
       
       
modification history
------------ -------   
*/

import jade.lang.acl.ACLMessage;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Vector;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.CopyOnWriteArrayList;

import com.rti.dds.domain.*;
import com.rti.dds.infrastructure.*;
import com.rti.dds.subscription.*;
import com.rti.dds.topic.*;
import com.rti.ndds.config.*;

// ===========================================================================

public class KeyValuePairSubscriberModule extends DataReaderAdapter {
	
	 DomainParticipant participant = null;
     Subscriber subscriber = null;
     HashMap<String, Topic> topics = new HashMap<String, Topic>(); 
     HashMap<String, KeyValuePairDataReader> readers = new HashMap<String, KeyValuePairDataReader>();
     String myAgentName = "";
     
     //Time to wait between sample reads
     final long receivePeriodMillisec = 250;
     
     //True while we want to keep reading
     private boolean continueReading = false;     
     
     //Vector storing received Kvps
     HashMap<String, ConcurrentLinkedQueue<KeyValueSimple>> receivedKeyValuePairQueues = new HashMap<String, ConcurrentLinkedQueue<KeyValueSimple>>();
     
     final String GENERAL_TOPIC_NAME = "general_announce";
     final String RECIPE_TOPIC_NAME = "recipe_topic";	
        
     
     //General = general subscriber and create general topic to go with it.
     public KeyValuePairSubscriberModule(int domainId, String agentName, boolean general) { 
    	 
    	 DomainParticipantFactoryQos factoryQoS = new DomainParticipantFactoryQos();
    	 DomainParticipantFactory.TheParticipantFactory.get_qos(factoryQoS);    	
       	 factoryQoS.resource_limits.max_objects_per_thread = 16384; 
    	 DomainParticipantFactory.TheParticipantFactory.set_qos(factoryQoS);
    	 
    	 //For testing and logging purposes
    	myAgentName = agentName;    	
    	
        // --- Create participant --- //

        /* To customize participant QoS, use
           the configuration file
           USER_QOS_PROFILES.xml */

        participant = DomainParticipantFactory.TheParticipantFactory.
            create_participant(
                domainId, DomainParticipantFactory.PARTICIPANT_QOS_DEFAULT,
                null /* listener */, StatusKind.STATUS_MASK_NONE);
        if (participant == null) {
            System.err.println("create_participant error\n");
            return;
        }                        

        // --- Create subscriber --- //

        /* To customize subscriber QoS, use
           the configuration file USER_QOS_PROFILES.xml */

        subscriber = participant.create_subscriber(
            DomainParticipant.SUBSCRIBER_QOS_DEFAULT, null /* listener */,
            StatusKind.STATUS_MASK_NONE);
        if (subscriber == null) {
            System.err.println("create_subscriber error\n");
            return;
        }     
        
        if (general) {        	
        
	        // --- Create topic --- //
	    
	        /* Register type before creating topic */
	        String typeName = KeyValuePairTypeSupport.get_type_name(); 
	        KeyValuePairTypeSupport.register_type(participant, typeName);
	
	        /* To customize topic QoS, use
	           the configuration file USER_QOS_PROFILES.xml */
	
	        Topic topic = participant.create_topic(
	            GENERAL_TOPIC_NAME,
	            typeName, DomainParticipant.TOPIC_QOS_DEFAULT,
	            null /* listener */, StatusKind.STATUS_MASK_NONE);
	        if (topic == null) {
	            System.err.println("create_topic error\n");
	            return;
	        }  else {
	        	topics.put(GENERAL_TOPIC_NAME, topic);
	        }
	    
	        // --- Create reader --- //       
	
	        /* To customize data reader QoS, use
	           the configuration file USER_QOS_PROFILES.xml */
	
	        KeyValuePairDataReader reader = (KeyValuePairDataReader)
	            subscriber.create_datareader(
	                topics.get(GENERAL_TOPIC_NAME), Subscriber.DATAREADER_QOS_DEFAULT, this,
	                StatusKind.STATUS_MASK_ALL);
	        if (reader == null) {
	            System.err.println("create_datareader error\n");
	            return;
	        }  else {
	        	readers.put(GENERAL_TOPIC_NAME, reader);
	        	receivedKeyValuePairQueues.put(GENERAL_TOPIC_NAME, new ConcurrentLinkedQueue<KeyValueSimple>());
	        }
	        
	        
        }
        
    }
     
     public void createTopic(String topicName) {
    	 
    	ArrayList<String> alreadySubscribedTopics = this.getAllTopics();
 		if (alreadySubscribedTopics.contains(topicName)) {
 			System.out.println("Topic " + topicName + " already exists. This is fine for PoCA Agent");
 		} else {
    	 
	    	 // --- Create topic --- //
	 	    
	        /* Register type before creating topic */
	        String typeName = KeyValuePairTypeSupport.get_type_name(); 
	        KeyValuePairTypeSupport.register_type(participant, typeName);
	
	        /* To customize topic QoS, use
	           the configuration file USER_QOS_PROFILES.xml */
	
	        Topic topic = participant.create_topic(
	            topicName,
	            typeName, DomainParticipant.TOPIC_QOS_DEFAULT,
	            null /* listener */, StatusKind.STATUS_MASK_NONE);
	        if (topic == null) {
	            System.err.println("create_topic error\n");
	            return;
	        }  else {
	        	//System.out.println("Put Topic");
	        	topics.put(topicName, topic);
	        }
	    
	        // --- Create reader --- //       
	
	        /* To customize data reader QoS, use
	           the configuration file USER_QOS_PROFILES.xml */
	
	        KeyValuePairDataReader reader = (KeyValuePairDataReader)
	            subscriber.create_datareader(
	                topics.get(topicName), Subscriber.DATAREADER_QOS_DEFAULT, this,
	                StatusKind.STATUS_MASK_ALL);
	        if (reader == null) {
	            System.err.println("create_datareader error\n");
	            return;
	        }  else {
	        	readers.put(topicName, reader);
	        	receivedKeyValuePairQueues.put(topicName, new ConcurrentLinkedQueue<KeyValueSimple>());
	        }
 		}
     }
    
    public void startReading() {   
    	
    	if (!continueReading) {
	    	continueReading = true;    	
	    	// --- Wait for data --- //  
	    	while (continueReading) {       		
	            try {     
	            	//System.out.println("general subscriber is waiting");
	            	//System.out.println("Subscriber has " + readers.size() + " topics");
	            	//System.out.println("Subscriber has " + receivedKeyValuePairQueues.get(GENERAL_TOPIC_NAME).size());
	                Thread.sleep(receivePeriodMillisec);  // in millisec
	            } catch (InterruptedException ix) {
	                System.err.println("INTERRUPTED");
	                break;
	            }
	        }  
    	} else {
    		return;
    	}
    }   
    
    public void removeTopic(String topicName) {
    	
    	topics.remove(topicName);
    	readers.remove(topicName).delete_contained_entities();
    }
    
    public boolean containsTopic(String topicName) {
    	return readers.containsKey(topicName);
    }
    
    public ArrayList<String> getAllTopics() {
    	
    	ArrayList<String> returnedTopicNames = new ArrayList<String>();
    	
      	for (Map.Entry<String, KeyValuePairDataReader> entry : readers.entrySet()) {
      		
      		String topic = entry.getValue().get_topicdescription().get_name();
      		returnedTopicNames.add(topic);      		
      	}
      	
      	return returnedTopicNames;
    }
    
    public ArrayList<String> getAllRecipeTopics() {
    	
    	ArrayList<String> returnedTopicNames = new ArrayList<String>();
    	
      	for (Map.Entry<String, KeyValuePairDataReader> entry : readers.entrySet()) {
      		
      		String topic = entry.getValue().get_topicdescription().get_name();
      		if (topic.equalsIgnoreCase(GENERAL_TOPIC_NAME) || topic.equalsIgnoreCase(RECIPE_TOPIC_NAME)) {
      			//Do nothing
      		} else {
      			returnedTopicNames.add(topic);
      		}
      		
      	}
      	
      	return returnedTopicNames;
    }

    //Stop listening
    public void shutDownKeyValueListener() {
    	
    	continueReading = false;
    	
    	if(participant != null) {
            participant.delete_contained_entities();

            DomainParticipantFactory.TheParticipantFactory.
                delete_participant(participant);
        }
    }           
    	
    KeyValuePairSeq _dataSeq = new KeyValuePairSeq();
    SampleInfoSeq _infoSeq = new SampleInfoSeq();

    public void on_data_available(DataReader reader) {    	
    	
    	KeyValuePairDataReader keyValuePairReader =
            (KeyValuePairDataReader)reader;
        
    	KeyValueSimple kvs = null;
        try {
            keyValuePairReader.take(
                _dataSeq, _infoSeq,
                ResourceLimitsQosPolicy.LENGTH_UNLIMITED,
                SampleStateKind.ANY_SAMPLE_STATE,
                ViewStateKind.ANY_VIEW_STATE,
                InstanceStateKind.ANY_INSTANCE_STATE);

            for(int i = 0; i < _dataSeq.size(); ++i) {
                SampleInfo info = (SampleInfo)_infoSeq.get(i);

                if (info.valid_data) {
                   KeyValuePair kvpReceived = ((KeyValuePair)_dataSeq.get(i));
                   kvs = new KeyValueSimple(kvpReceived.key, kvpReceived.source, kvpReceived.value);                  
                     
                   //System.out.println("KeyValuePairSubscriber - Some data receieved - " + keyValuePairReader.get_topicdescription().get_name());
                }
            }
        } catch (RETCODE_NO_DATA noData) {
            // No data to process
        } finally {
        	try {
	            keyValuePairReader.return_loan(_dataSeq, _infoSeq);  
	            receivedKeyValuePairQueues.get(reader.get_topicdescription().get_name()).add(kvs);
        	} 
        	catch (Exception e) {
        		System.out.println("Rare null pointer exception in Key Value Subscriber.");
        	}
        }
    }
    
    //Keeps the received pairs until the agent requests them via the subscriber.
    public KeyValueSimple getReceivedKeyValuePair(String topicName) {    	
    	
    	/*if (receivedKeyValuePairQueues.get(topicName).size() != 0) {
	    	System.out.println(myAgentName + " number of queued messages: " + receivedKeyValuePairQueues.get(topicName).size() + " ");
	    	Iterator<KeyValueSimple> iter = receivedKeyValuePairQueues.get(topicName).iterator();
	    	while (iter.hasNext()) {
	    		KeyValueSimple kvs = iter.next();
	    		System.out.print(" | " + kvs.getKey() + " : " + kvs.getValue());
	    	}
	    	System.out.println(); 
	    }*/
    	
    	return receivedKeyValuePairQueues.get(topicName).poll();       	
		
    }
}



        